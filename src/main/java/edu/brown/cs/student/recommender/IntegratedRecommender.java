package edu.brown.cs.student.recommender;

import edu.brown.cs.student.bloomfilter.BloomFilterRecommender;
import edu.brown.cs.student.client.Student;
import edu.brown.cs.student.kdtree.KdTree;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * A Recommender system that integrates KD Tree and Bloom Filter recommendations for students.
 */
public class IntegratedRecommender {
  private BloomFilterRecommender bloomFilterRecommender = null;
  private KdTree kdTree = null;

  /**
   * IntegratedRecommender comparator.
   *
   * @param studentMap - a map from student ID to student object.
   */
  public IntegratedRecommender(HashMap<Integer, Student> studentMap) {
    // Build bloom filter recommender
    this.bloomFilterRecommender = new BloomFilterRecommender(studentMap, 0.0005);
    // get number of KDtree point dimensions
    Item[] studentArray = (Item[]) studentMap.values().toArray();
    int dim = studentArray[0].getKdPoint().length;
    // Build KD tree
    this.kdTree = new KdTree(dim, studentArray);
  }

  /**
   * Generates k recommendations for the target item based on the Bloom Filter and KD tree recommenders
   *
   * @param targetItem is the Item to generate recommendations for.
   * @param k is the desired number of recommendations.
   * @return a list of student ID integers representing the recommended group.
   */
  public List<Integer> getTopKRecommendationIDs(Item targetItem, int k) {
    List<Item> bloomRecs = this.bloomFilterRecommender.getTopKRecommendations(targetItem, k);
    int[] kdTreeRecIDs = this.kdTree.getArrayOfKnnIds(targetItem.getKdPoint(), k);
    List<Integer> mergedRecs = this.mergeRecommendationLists(bloomRecs, kdTreeRecIDs, k);
    return mergedRecs;
  }

  /**
   * Generates k recommendations for the target item based on the Bloom Filter and KD tree recommenders
   *
   * @param bloomFilterRecs is the list of recommended Items generated by the BloomFilterRecommender.
   * @param kdTreeRecs is the array of integer student IDs generated by the KD Tree recommender.
   * @return a list of student ID integers representing the recommended group.
   */
  private List<Integer> mergeRecommendationLists(List<Item> bloomFilterRecs, int[] kdTreeRecs,
                                                 int k) {
    List<Integer> recList = new ArrayList<Integer>();
    // TO DO: add protection for when k > # students
    for (int i = 0; i < k; i++) {
      Item bloomRec = bloomFilterRecs.get(i);
      if (!recList.contains(bloomRec) && recList.size() < k) {
        recList.add(bloomRec.getElementID());
      }
      int kdRecID = kdTreeRecs[i];
      if (!recList.contains(kdRecID) && recList.size() < k) {
        recList.add(kdRecID);
      }
      if (recList.size() >= k) {
        return recList;
      }
    }
    return recList;
  }
}
